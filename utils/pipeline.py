from utils.load_data import *
from utils.myllm import MyChatGPT
from utils.database import MYSQLDB
from utils.helper import PipelineContext, AgentResult
from utils.general_prompt import *
from utils.reasoner import SUFFICIENCY_agent, ANSWER_agent
# from utils.agents.text_helper import DECOMPOSE_agent_t, COMPOSE_agent_t, DECOMPOSE_needs
from utils.agents.column_selector import SELECT_clause, BASIC_clause
from utils.agents.withas import WITHAS_clause
from utils.agents.row_selector import WHERE_clause
from utils.agents.aggfunc2 import AggFun_clause2
from utils.agents.order2 import ORDERBY_clause2
from utils.agents.aggfunc1 import AggFun_clause1
from utils.agents.order1 import ORDERBY_clause1

def agent_pipeline(ctx: PipelineContext, standard_answer: str) -> tuple[bool, bool, str, str, dict]:
    agent_map = {
        "Basic": BASIC_clause,
        "WithAs": WITHAS_clause,
        "TempTable": TEMP_table_prompt,
        "Where": WHERE_clause,
        "Select": SELECT_clause,
        "Agg2": AggFun_clause2,
        "Order2": ORDERBY_clause2,
        "Agg1": AggFun_clause1,
        "Order1": ORDERBY_clause1,
    }
    valid_flag = True
    answer_flag = False
    sufficiency_flag = False
    sql_query = ""
    generated_answer = ""
    log = ctx.log

    try:
        current_agent = "Basic"
        agent_fn = agent_map[current_agent]
        result = agent_fn(ctx)
        valid_flag = result.flag_valid
        if not valid_flag:
            raise ValueError("Invalid SQL query generated by Basic Agent.")
        sql_1 = result.updates["sql1"]
        sql_2 = result.updates["sql2"]

        sufficiency_flag = SUFFICIENCY_agent(
            llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
            standard_answer = standard_answer, sql_query = sql_1, log = log
        )
        if sufficiency_flag:
            answer_flag, generated_answer, log = ANSWER_agent(
                llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
                standard_answer = standard_answer, sql_query = sql_1, log = log
            )
            return valid_flag, answer_flag, sql_1, generated_answer, log
        if sql_2:
            sufficiency_flag = SUFFICIENCY_agent(
                llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
                standard_answer = standard_answer, sql_query = sql_2, log = log
            )
            if sufficiency_flag:
                answer_flag, generated_answer, log = ANSWER_agent(
                    llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
                    standard_answer = standard_answer, sql_query = sql_2, log = log
                )
                return valid_flag, answer_flag, sql_2, generated_answer, log

        sql_query = sql_1
        ctx.previous_sql_query = sql_1
        current_agent = result.next_agent
        while current_agent:
            agent_fn = agent_map[current_agent]
            result = agent_fn(ctx)
            valid_flag = result.flag_valid
            ctx.flag = False
            if not valid_flag:
                for sql_query in reversed(ctx.log["sqls"]):
                    sql_result = ctx.sqldb.execute_query(sql_query)
                    if sql_result:
                        ctx.previous_sql_query = sql_query
                        answer_flag, generated_answer, log = ANSWER_agent(
                            llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
                            standard_answer = standard_answer, sql_query = sql_query, log = log
                        )
                        return valid_flag, answer_flag, sql_query, generated_answer, log
                raise ValueError(f"Invalid SQL query generated by {current_agent} Agent.")
            sql_query = result.updates["sql"]
            previous_agent = current_agent
            current_agent = result.next_agent
            if current_agent == "TempTable":
                ctx.previous_sql_query = sql_query
                continue
            if previous_agent == "TempTable":
                ctx.title = result.updates["table_name"]
                ctx.prompt_schema = result.updates["prompt"]
                ctx.total_rows = result.updates["total_number"]
                continue
            if not result.updates["flag"]:
                ctx.previous_sql_query = sql_query
                continue
            else:
                ctx.flag = True
            sufficiency_flag = SUFFICIENCY_agent(
                llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
                standard_answer = standard_answer, sql_query = sql_query, log = log
            )
            if sufficiency_flag:
                answer_flag, generated_answer, log = ANSWER_agent(
                    llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
                    standard_answer = standard_answer, sql_query = sql_query, log = log
                )
                return valid_flag, answer_flag, sql_query, generated_answer, log
            ctx.previous_sql_query = sql_query
        answer_flag, generated_answer, log = ANSWER_agent(
            llm = ctx.llm, sqldb = ctx.sqldb, question = ctx.question, prompt_schema = ctx.prompt_schema, title = ctx.title,
            standard_answer = standard_answer, sql_query = sql_query, log = log
        )
        return valid_flag, answer_flag, sql_query, generated_answer, log
    except Exception as e:
        valid_flag = False
        print("Error: ", e)
        return valid_flag, answer_flag, sql_query, generated_answer, log